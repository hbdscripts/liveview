/**
 * Tracker table/metric definitions for the diagnostics modal.
 *
 * Goal: keep reporting consistent and auditable. When adding/changing a dashboard table or metric,
 * update this manifest so /api/config-status can surface what each UI element is using.
 */
const DEFINITIONS_VERSION = 37;
const LAST_UPDATED = '2026-02-15';

/**
 * NOTE: Keep this as data (not executable logic) so it remains easy to review.
 * `config-status` will attach runtime checks (DB tables present, token stored, etc).
 */
const TRACKER_TABLE_DEFINITIONS = [
  {
    id: 'home_sessions_table',
    page: 'Home',
    name: 'Sessions table (live / paginated)',
    ui: { elementIds: ['sessions-table'] },
    endpoint: {
      method: 'GET',
      path: '/api/sessions',
      params: [
        'filter=active|today|recent|abandoned|converted|all',
        'range=today|yesterday|3d|7d|1h|d:YYYY-MM-DD|r:YYYY-MM-DD:YYYY-MM-DD',
        'timezone/timeZone',
        'limit, offset',
      ],
    },
    sources: [
      { kind: 'db', tables: ['sessions', 'visitors'], note: 'Sessions list + returning flags' },
      { kind: 'db', tables: ['events'], note: 'Used for session history + side panel' },
      { kind: 'pixel', note: 'Populates sessions/events via /api/ingest' },
    ],
    columns: [
      { name: 'Landing Page', value: 'sessions.first_path / sessions.first_product_handle (set on first event)' },
      { name: 'Compliance', value: 'Always shows check/warn (from /api/fraud/markers) + optional sale icon when sessions.has_purchased=1; links to /tools/click-order-lookup' },
      { name: 'GEO', value: 'sessions.country_code (or visitors.last_country fallback in API)' },
      { name: 'Source', value: 'sessions.traffic_source_key (mapped from UTMs/referrer rules)' },
      { name: 'Device', value: 'sessions.ua_device_type + ua_platform (derived from ingest User-Agent)' },
      { name: 'Cart', value: 'sessions.cart_qty + sessions.cart_value (from pixel cart events)' },
      { name: 'Arrived', value: 'sessions.started_at' },
      { name: 'Seen', value: 'sessions.last_seen' },
      { name: 'History', value: 'events(type/path/product_handle/qty_delta/checkout_state_json)' },
    ],
    math: [],
    respectsReporting: { ordersSource: false, sessionsSource: false },
    requires: { dbTables: ['sessions', 'visitors', 'events'], shopifyToken: false },
  },
  {
    id: 'home_fraud_markers',
    page: 'Home',
    name: 'Compliance / fraud markers (sessions + latest sales)',
    ui: { elementIds: ['sessions-table', 'latest-sales-table'] },
    endpoint: {
      method: 'GET',
      path: '/api/fraud/markers',
      params: ['entityType=session', 'ids=session_id,... (batched)'],
    },
    sources: [
      { kind: 'db', tables: ['fraud_evaluations'], note: 'Indexed marker lookup (cached; fail-open)' },
      { kind: 'pixel', note: 'Evaluations are created on checkout_completed ingest (never blocks dashboards)' },
    ],
    columns: [
      { name: 'Triggered', value: 'fraud_evaluations.triggered (score >= threshold)' },
      { name: 'Score', value: 'fraud_evaluations.score (0-100)' },
      { name: 'Flags', value: 'fraud_evaluations.flags_json (deterministic signals)' },
    ],
    math: [
      { name: 'Fail-open', value: 'If fraud tables/config are missing or API fails, sessions tables show the default “passed” check; latest sales omits the warning icon' },
    ],
    respectsReporting: { ordersSource: false, sessionsSource: false },
    requires: { dbTables: ['fraud_evaluations'], shopifyToken: false },
  },
  {
    id: 'home_fraud_detail',
    page: 'Home',
    name: 'Fraud detail modal (legacy quick view)',
    ui: { elementIds: ['fraud-detail-modal'] },
    endpoint: {
      method: 'GET',
      path: '/api/fraud/detail',
      params: ['entityType=session|order', 'entityId=...'],
    },
    sources: [
      { kind: 'db', tables: ['fraud_evaluations'], note: 'Safe evidence snapshot + flags + optional AI narrative' },
      { kind: 'db', tables: ['affiliate_attribution_sessions'], note: 'First-touch/late attribution capture feeding the evidence snapshot' },
      { kind: 'ai', note: 'Optional: OpenAI narrative (feature-flagged; never blocks ingest/UI)' },
    ],
    columns: [
      { name: 'Evidence', value: 'fraud_evaluations.evidence_json (safe snapshot; no raw IP)' },
      { name: 'Resolution', value: 'fraud_evaluations.resolved_status/resolved_by/resolved_note' },
    ],
    math: [],
    respectsReporting: { ordersSource: false, sessionsSource: false },
    requires: { dbTables: ['fraud_evaluations'], shopifyToken: false },
  },
  {
    id: 'kpi_grid',
    page: 'Home',
    name: 'Top KPI grid',
    ui: { elementIds: ['live-kpi-grid'] },
    endpoint: { method: 'GET', path: '/api/kpis', params: ['range=...', 'force=1 (optional)'] },
    sources: [
      { kind: 'db', tables: ['sessions'], note: 'Sessions (human-only filtering in queries)' },
      { kind: 'db', tables: ['orders_shopify', 'reconcile_state'], note: 'Shopify truth cache (paid orders). Pixel purchases are debug-only.' },
      { kind: 'db', tables: ['shopify_sessions_snapshots'], note: 'Optional denominator when sessionsSource=shopify_sessions' },
      { kind: 'shopify', note: 'Orders API sync (throttled) to keep truth current' },
    ],
    columns: [
      { name: 'Revenue', value: 'sales[range] (GBP)', formula: 'SUM(orders_shopify.total_price) converted to GBP (truth; never exceeds Shopify)' },
      { name: 'Conversion', value: 'conversion[range] (%)', formula: 'convertedCount / sessionsCount × 100 (Orders / Sessions)' },
      { name: 'AOV', value: 'aov[range] (GBP)', formula: 'Revenue / convertedCount' },
      { name: 'Sessions', value: 'trafficBreakdown[range].human_sessions', formula: 'sessionsSource=sessions → COUNT(sessions.started_at); sessionsSource=shopify_sessions → ShopifyQL snapshot count (day-like ranges only)' },
      { name: 'Bounce', value: 'bounce[range] (%)', formula: 'single-page sessions / sessions × 100 (human-only)' },
    ],
    math: [
      { name: 'Traffic mode', value: 'human_only (exclude cf_known_bot=1)' },
      { name: 'Time basis', value: 'range bounds are admin timezone day/range (see getRangeBounds)' },
    ],
    respectsReporting: { ordersSource: false, sessionsSource: true },
    requiresByReporting: {
      sessionsSource: {
        shopify_sessions: ['shopify_sessions_snapshots'],
      },
    },
    requires: { dbTables: ['sessions'], shopifyToken: false },
  },
  {
    id: 'business_snapshot_modal',
    page: 'Header',
    name: 'Business Snapshot modal + Profit Rules',
    ui: { elementIds: ['kexo-business-snapshot-btn', 'business-snapshot-modal', 'profit-rules-modal'] },
    endpoint: {
      method: 'GET',
      path: '/api/business-snapshot',
      params: ['mode=yearly|monthly', 'year=YYYY (when mode=yearly)', 'month=YYYY-MM (when mode=monthly)'],
    },
    sources: [
      { kind: 'db', tables: ['settings'], note: 'profit_rules_v1 persistence for estimated profit toggles/rules' },
      { kind: 'db', tables: ['orders_shopify', 'customer_order_facts'], note: 'Revenue/orders/customer/LTV and country-scoped profit deductions from Shopify truth orders (checkout_token only for online store alignment)' },
      { kind: 'db', tables: ['orders_shopify_line_items'], note: 'COGS (Cost of Goods) computed from paid truth line-items + Shopify variant unitCost' },
      { kind: 'db', tables: ['google_ads_spend_hourly'], note: 'Optional: Google Ads spend included in Cost when enabled (ADS_DB_URL / Ads DB)' },
      { kind: 'shopifyql', note: 'Sessions + conversion_rate from ShopifyQL sessions dataset (SINCE/UNTIL range)' },
      { kind: 'shopify', note: 'Shop name (title) + variant unitCost (for COGS) via Admin API' },
      { kind: 'fx', note: 'Currency conversion to GBP for multi-currency order totals' },
    ],
    columns: [
      { name: 'Financial', value: 'Full-width “Revenue & Cost” line chart + optional Profit section (Estimated Profit / Margin / Deductions)' },
      { name: 'Performance', value: 'Sessions, Orders, Conversion Rate, AOV' },
      { name: 'Customers', value: 'New, Returning, Repeat Purchase Rate cards + header LTV callout (cohort-aware)' },
      { name: 'Profit Rules', value: 'Percent of Revenue, Fixed per Order, Fixed per Period with country targeting' },
      { name: 'Integrations', value: 'Profit Rules → Integrations tab: toggles (e.g. include Google Ads spend in Cost chart)' },
      { name: 'Charts', value: 'ApexCharts: Revenue & Cost animated trend chart + per-card KPI sparklines + decorative LTV radial header arc' },
      { name: 'UI mode', value: 'Yearly-only modal UX (current year vs previous year); per-KPI validation tooltips show both periods' },
    ],
    math: [
      { name: 'Estimated profit', value: 'Revenue - SUM(applicable rule deductions) in deterministic sort order' },
      { name: 'Margin %', value: 'EstimatedProfit / Revenue × 100 (null-safe)' },
      { name: 'Cost (chart line)', value: 'COGS + enabled Profit Rule deductions + optional Google Ads spend when enabled' },
      { name: 'Unknown country handling', value: 'Only All-country rules apply when order country is unknown' },
      { name: 'Conversion rate', value: 'ShopifyQL conversion_rate (sessions dataset) over the selected SINCE/UNTIL range (fallback: checkout orders / sessions when conversion_rate is missing/0 but sessions exist)' },
      { name: 'Returning customers', value: 'Distinct customers with >=2 paid orders by the end of the selected window (counts repeats inside the window too)' },
      { name: 'Repeat purchase rate', value: 'ReturningCustomers / DistinctCustomers × 100 (null-safe)' },
      { name: 'Yearly comparison window', value: 'Yearly mode compares Jan-01→today-in-year against Jan-01→same-day previous year' },
      { name: 'Monthly comparison window', value: 'Monthly mode compares selected month against same month in previous year (partial month when current month)' },
    ],
    respectsReporting: { ordersSource: false, sessionsSource: true },
    requires: { dbTables: ['settings', 'orders_shopify', 'orders_shopify_line_items'], shopifyToken: true },
  },
  {
    id: 'dashboard_overview_top_products_table',
    page: 'Overview',
    name: 'Top products table',
    ui: { elementIds: ['dash-top-products'] },
    endpoint: {
      method: 'GET',
      path: '/api/dashboard-series',
      params: [
        'range=today|yesterday|3d|7d|14d|30d|month|1h|d:YYYY-MM-DD|r:YYYY-MM-DD:YYYY-MM-DD',
        'force=1 (optional)',
      ],
    },
    sources: [
      { kind: 'db', tables: ['orders_shopify_line_items'], note: 'Paid truth line item revenue + distinct order count grouped by product_id in range' },
      { kind: 'db', tables: ['sessions'], note: 'Sessions by sessions.first_product_handle for CR% denominator (human_only; started_at in range)' },
      { kind: 'shopify', note: 'Product metadata for title/handle/thumb_url when token stored' },
      { kind: 'fx', note: 'Revenue converted to GBP (fx.getRatesToGbp)' },
    ],
    columns: [
      { name: 'Product', value: 'topProducts[].title + handle (links to /products/{handle})' },
      { name: 'Revenue', value: 'topProducts[].revenue (GBP)' },
      { name: 'Orders', value: 'topProducts[].orders' },
      { name: 'CR%', value: 'topProducts[].cr', formula: 'orders / sessions × 100 (sessions counted by product handle)' },
    ],
    math: [
      { name: 'Traffic mode', value: 'human_only (exclude cf_known_bot=1)' },
      { name: 'CR cap', value: 'CR% is capped at 100%' },
    ],
    respectsReporting: { ordersSource: false, sessionsSource: false },
    requires: { dbTables: ['orders_shopify_line_items', 'sessions'], shopifyToken: false },
  },
  {
    id: 'dashboard_overview_top_countries_table',
    page: 'Overview',
    name: 'Top countries table',
    ui: { elementIds: ['dash-top-countries'] },
    endpoint: {
      method: 'GET',
      path: '/api/dashboard-series',
      params: [
        'range=today|yesterday|3d|7d|14d|30d|month|1h|d:YYYY-MM-DD|r:YYYY-MM-DD:YYYY-MM-DD',
        'force=1 (optional)',
      ],
    },
    sources: [
      { kind: 'db', tables: ['orders_shopify'], note: 'Paid truth orders in range; country from orders_shopify.raw_json shipping/billing country_code' },
      { kind: 'db', tables: ['sessions'], note: 'Sessions by COALESCE(s.country_code, s.cf_country) for CR% denominator (human_only; started_at in range)' },
      { kind: 'fx', note: 'Revenue converted to GBP (fx.getRatesToGbp)' },
    ],
    columns: [
      { name: 'Country', value: 'topCountries[].country (2-letter ISO)' },
      { name: 'Revenue', value: 'topCountries[].revenue (GBP)' },
      { name: 'Orders', value: 'topCountries[].orders' },
      { name: 'CR%', value: 'topCountries[].cr', formula: 'orders / sessions × 100 (sessions counted by session country)' },
    ],
    math: [
      { name: 'Traffic mode', value: 'human_only (exclude cf_known_bot=1)' },
      { name: 'CR cap', value: 'CR% is capped at 100%' },
      { name: 'Country basis', value: 'Orders country uses Shopify order addresses; sessions country uses session geolocation (can differ)' },
    ],
    respectsReporting: { ordersSource: false, sessionsSource: false },
    requires: { dbTables: ['orders_shopify', 'sessions'], shopifyToken: false },
  },
  {
    id: 'dashboard_overview_trending_up_table',
    page: 'Overview',
    name: 'Trending up table',
    ui: { elementIds: ['dash-trending-up'] },
    endpoint: {
      method: 'GET',
      path: '/api/dashboard-series',
      params: [
        'range=today|yesterday|3d|7d|14d|30d|month|1h|d:YYYY-MM-DD|r:YYYY-MM-DD:YYYY-MM-DD',
        'force=1 (optional)',
      ],
    },
    sources: [
      { kind: 'db', tables: ['orders_shopify_line_items'], note: 'Paid truth line item revenue/orders by product_id in now + prev windows' },
      { kind: 'db', tables: ['sessions'], note: 'Sessions by sessions.first_product_handle in now + prev windows (human_only)' },
      { kind: 'shopify', note: 'Product metadata for title/handle/thumb_url when token stored' },
      { kind: 'fx', note: 'Revenue converted to GBP (fx.getRatesToGbp)' },
    ],
    columns: [
      { name: 'Product', value: 'trendingUp[].title + handle' },
      { name: 'Revenue', value: 'trendingUp[].deltaRevenue (GBP)', formula: 'revenueNow - revenuePrev' },
      { name: 'Orders', value: 'trendingUp[].deltaOrders', formula: 'ordersNow - ordersPrev' },
      { name: 'CR%', value: 'trendingUp[].cr', formula: 'ordersNow / sessionsNow × 100' },
    ],
    math: [
      { name: 'Compare window', value: 'prev period is equal duration immediately before now window (today is time-of-day aligned to yesterday)' },
      { name: 'Traffic mode', value: 'human_only (exclude cf_known_bot=1)' },
      { name: 'CR cap', value: 'CR% is capped at 100%' },
    ],
    respectsReporting: { ordersSource: false, sessionsSource: false },
    requires: { dbTables: ['orders_shopify_line_items', 'sessions'], shopifyToken: false },
  },
  {
    id: 'dashboard_overview_trending_down_table',
    page: 'Overview',
    name: 'Trending down table',
    ui: { elementIds: ['dash-trending-down'] },
    endpoint: {
      method: 'GET',
      path: '/api/dashboard-series',
      params: [
        'range=today|yesterday|3d|7d|14d|30d|month|1h|d:YYYY-MM-DD|r:YYYY-MM-DD:YYYY-MM-DD',
        'force=1 (optional)',
      ],
    },
    sources: [
      { kind: 'db', tables: ['orders_shopify_line_items'], note: 'Paid truth line item revenue/orders by product_id in now + prev windows' },
      { kind: 'db', tables: ['sessions'], note: 'Sessions by sessions.first_product_handle in now + prev windows (human_only)' },
      { kind: 'shopify', note: 'Product metadata for title/handle/thumb_url when token stored' },
      { kind: 'fx', note: 'Revenue converted to GBP (fx.getRatesToGbp)' },
    ],
    columns: [
      { name: 'Product', value: 'trendingDown[].title + handle' },
      { name: 'Revenue', value: 'trendingDown[].deltaRevenue (GBP)', formula: 'revenueNow - revenuePrev' },
      { name: 'Orders', value: 'trendingDown[].deltaOrders', formula: 'ordersNow - ordersPrev' },
      { name: 'CR%', value: 'trendingDown[].cr', formula: 'ordersNow / sessionsNow × 100' },
    ],
    math: [
      { name: 'Compare window', value: 'prev period is equal duration immediately before now window (today is time-of-day aligned to yesterday)' },
      { name: 'Traffic mode', value: 'human_only (exclude cf_known_bot=1)' },
      { name: 'CR cap', value: 'CR% is capped at 100%' },
    ],
    respectsReporting: { ordersSource: false, sessionsSource: false },
    requires: { dbTables: ['orders_shopify_line_items', 'sessions'], shopifyToken: false },
  },
  {
    id: 'dashboard_live_latest_sales_table',
    page: 'Live View',
    name: 'Latest sales table',
    ui: { elementIds: ['latest-sales-table'] },
    endpoint: { method: 'GET', path: '/api/latest-sales', params: ['limit=5 (optional)'] },
    sources: [
      { kind: 'db', tables: ['sessions', 'visitors'], note: 'Latest converted sessions ordered by purchased_at desc' },
      { kind: 'db', tables: ['purchases', 'purchase_events'], note: 'Evidence + dedupe links (order_id / checkout_token) for mapping sessions -> truth orders' },
      { kind: 'db', tables: ['orders_shopify', 'orders_shopify_line_items'], note: 'Truth order total + top line item (product_id + title) for stable product mapping' },
      { kind: 'shopify', note: 'Best-effort product handle lookup by product_id when shop token is stored' },
      { kind: 'fx', note: 'Order total converted to GBP (fx.getRatesToGbp)' },
      { kind: 'pixel', note: 'Populates sessions/purchases/purchase_events via /api/ingest (checkout_* events set has_purchased, purchased_at, order_total/currency, evidence keys)' },
    ],
    columns: [
      { name: 'Country', value: 'country_code', formula: 'COALESCE(s.country_code, visitors.last_country, s.cf_country)' },
      { name: 'Product', value: 'product_title + product_id (top truth line item; handle optional)' },
      { name: 'Ago', value: 'purchased_at', formula: 'relative time string (client)' },
      { name: 'Value', value: 'order_total_gbp (fallback order_total + order_currency)', formula: 'money formatting (client)' },
    ],
    math: [],
    respectsReporting: { ordersSource: false, sessionsSource: false },
    requires: { dbTables: ['sessions', 'visitors', 'orders_shopify', 'orders_shopify_line_items', 'purchase_events'], shopifyToken: false },
  },
  {
    id: 'breakdown_country',
    page: 'Countries',
    name: 'Country table',
    ui: { elementIds: ['country-table'] },
    endpoint: { method: 'GET', path: '/api/stats', params: ['range=... (same picker as dashboard)'] },
    sources: [
      { kind: 'db', tables: ['sessions'], note: 'Denominator sessions by country (started_at in range, human-only)' },
      { kind: 'db', tables: ['orders_shopify'], note: 'Numerator/revenue from Shopify truth orders, grouped by order country (shipping/billing) parsed from orders_shopify.raw_json' },
      { kind: 'fx', note: 'Revenue converted to GBP (fx.getRatesToGbp)' },
    ],
    columns: [
      { name: 'Country', value: 'sessions.country_code (2-letter ISO; excludes XX)' },
      { name: 'CR', value: 'converted / total', formula: 'Orders / Sessions' },
      { name: 'Orders', value: 'converted', formula: 'COUNT(DISTINCT orders_shopify.order_id) for paid orders in range, grouped by order country' },
      { name: 'Sessions', value: 'total', formula: 'COUNT(sessions) started_at in range, human-only' },
      { name: 'Rev', value: 'revenue (GBP)', formula: 'SUM(order_total) converted to GBP' },
    ],
    math: [
      { name: 'Order country', value: 'Use Shopify order shipping_address.country_code (fallback billing_address.country_code) from orders_shopify.raw_json' },
    ],
    respectsReporting: { ordersSource: false, sessionsSource: false },
    requires: { dbTables: ['sessions'], shopifyToken: false },
  },
  {
    id: 'overview_breakdown_products_table',
    page: 'Overview',
    name: 'Product breakdown table (Title)',
    ui: { elementIds: ['breakdown-product-table', 'breakdown-title-body'] },
    endpoint: { method: 'GET', path: '/api/shopify-leaderboard', params: ['shop=...', 'range=...', 'topProducts/topTypes (optional)', 'force=1 (optional)'] },
    sources: [
      { kind: 'db', tables: ['orders_shopify_line_items'], note: 'Paid line item revenue grouped by product_id (truth line items; rolling 7d in admin TZ)' },
      { kind: 'db', tables: ['reconcile_state', 'reconcile_snapshots'], note: 'Best-effort reconciliation state (route calls salesTruth.ensureReconciled for 7d)' },
      { kind: 'shopify', note: 'Product metadata for product image + product_type (REST /products/{id}.json) when token stored' },
      { kind: 'fx', note: 'Revenue converted to GBP (fx.getRatesToGbp)' },
    ],
    columns: [
      { name: 'Product', value: 'byTitle[]', formula: 'Top products by SUM(line_revenue) over rolling 7d (converted to GBP)' },
      { name: 'Rev', value: 'revenueGbp' },
      { name: 'CR%', value: 'cr' },
    ],
    math: [
      { name: 'Range', value: 'Rolling 7d (startOfDay -6d → now) in admin time zone' },
      { name: 'Truth basis', value: 'Paid, non-test, non-cancelled orders from orders_shopify_line_items' },
    ],
    respectsReporting: { ordersSource: false, sessionsSource: false },
    requires: { dbTables: ['orders_shopify_line_items'], shopifyToken: false },
  },
  {
    id: 'overview_breakdown_types_table',
    page: 'Overview',
    name: 'Type breakdown table',
    ui: { elementIds: ['breakdown-type-table', 'breakdown-type-body'] },
    endpoint: { method: 'GET', path: '/api/shopify-leaderboard', params: ['shop=...', 'range=...', 'topProducts/topTypes (optional)', 'force=1 (optional)'] },
    sources: [
      { kind: 'db', tables: ['orders_shopify_line_items'], note: 'Paid line item revenue grouped by product_type via Shopify product metadata' },
      { kind: 'db', tables: ['reconcile_state', 'reconcile_snapshots'], note: 'Best-effort reconciliation state (route calls salesTruth.ensureReconciled for 7d)' },
      { kind: 'shopify', note: 'Product metadata for product_type (REST /products/{id}.json) when token stored' },
      { kind: 'fx', note: 'Revenue converted to GBP (fx.getRatesToGbp)' },
    ],
    columns: [
      { name: 'Type', value: 'byType[]' },
      { name: 'Rev', value: 'revenueGbp' },
      { name: 'CR%', value: 'cr' },
    ],
    math: [
      { name: 'Range', value: 'Rolling 7d (startOfDay -6d → now) in admin time zone' },
      { name: 'Truth basis', value: 'Paid, non-test, non-cancelled orders from orders_shopify_line_items' },
    ],
    respectsReporting: { ordersSource: false, sessionsSource: false },
    requires: { dbTables: ['orders_shopify_line_items'], shopifyToken: false },
  },
  {
    id: 'overview_breakdown_finishes_table',
    page: 'Overview',
    name: 'Finish breakdown table',
    ui: { elementIds: ['breakdown-finish-table', 'breakdown-finish-body'] },
    endpoint: { method: 'GET', path: '/api/shopify-finishes', params: ['shop=...', 'range=...', 'force=1 (optional)'] },
    sources: [
      { kind: 'db', tables: ['orders_shopify_line_items'], note: 'Paid line item revenue grouped by inferred finish from variant_title' },
      { kind: 'db', tables: ['reconcile_state', 'reconcile_snapshots'], note: 'Best-effort reconciliation state (route calls salesTruth.ensureReconciled)' },
      { kind: 'shopify', note: 'Used to reconcile truth data when token stored (best results). Without token, table relies on existing DB truth.' },
      { kind: 'fx', note: 'Revenue converted to GBP (fx.getRatesToGbp)' },
    ],
    columns: [
      { name: 'Finish', value: 'Gold | Silver | Vermeil | Solid Silver' },
      { name: 'Rev', value: 'revenueGbp' },
      { name: 'CR%', value: 'cr' },
    ],
    math: [
      { name: 'Finish inference', value: 'Derived from variant_title keywords (normalizeFinishKey in shopifyFinishes route)' },
    ],
    respectsReporting: { ordersSource: false, sessionsSource: false },
    requires: { dbTables: ['orders_shopify_line_items'], shopifyToken: false },
  },
  {
    id: 'overview_breakdown_lengths_table',
    page: 'Overview',
    name: 'Length breakdown table',
    ui: { elementIds: ['breakdown-length-table', 'breakdown-length-body'] },
    endpoint: { method: 'GET', path: '/api/shopify-lengths', params: ['shop=...', 'range=...', 'force=1 (optional)'] },
    sources: [
      { kind: 'db', tables: ['orders_shopify_line_items'], note: 'Paid line item revenue grouped by inferred length (inches) from variant_title' },
      { kind: 'db', tables: ['reconcile_state', 'reconcile_snapshots'], note: 'Best-effort reconciliation state (route calls salesTruth.ensureReconciled)' },
      { kind: 'shopify', note: 'Used to reconcile truth data when token stored (best results). Without token, table relies on existing DB truth.' },
      { kind: 'fx', note: 'Revenue converted to GBP (fx.getRatesToGbp)' },
    ],
    columns: [
      { name: 'Length', value: '12" | 13" | … | 21"' },
      { name: 'Rev', value: 'revenueGbp' },
      { name: 'CR%', value: 'cr' },
    ],
    math: [
      { name: 'Length inference', value: 'Derived from variant_title (e.g. 15" Inches) using normalizeLengthInches in shopifyLengths route' },
    ],
    respectsReporting: { ordersSource: false, sessionsSource: false },
    requires: { dbTables: ['orders_shopify_line_items'], shopifyToken: false },
  },
  {
    id: 'breakdown_aov_cards',
    page: 'Overview',
    name: 'Average Order Value (AOV) table (by country)',
    ui: { elementIds: ['breakdown-aov-table', 'breakdown-aov-body'] },
    endpoint: { method: 'GET', path: '/api/stats', params: ['range=... (same picker as dashboard)'] },
    sources: [
      { kind: 'db', tables: ['sessions'], note: 'Country sessions (human-only) + attributed orders for that country' },
      { kind: 'db', tables: ['purchases'], note: 'ordersSource=pixel: revenue/orders derived from purchases table (deduped)' },
      { kind: 'db', tables: ['purchase_events', 'orders_shopify'], note: 'ordersSource=orders_shopify: revenue/orders via evidence-linked truth orders' },
      { kind: 'fx', note: 'Revenue converted to GBP' },
    ],
    columns: [
      { name: 'Country (left)', value: 'Flag + country name (left-aligned)' },
      { name: 'AOV (middle)', value: 'aov (GBP)', formula: 'Revenue / Orders, shown in center column' },
      { name: 'Revenue (right)', value: 'revenue (GBP)', formula: 'SUM(order_total) converted to GBP, shown in right column' },
    ],
    math: [
      { name: 'Layout', value: '3-column card: Flag+Country | AOV | Revenue. Sorted by revenue desc. Mobile: swipe pages of 5.' },
      { name: 'Important', value: 'This is derived from the same country rows as the Country table (uses the country.aov and country.revenue fields returned by /api/stats).' },
    ],
    respectsReporting: { ordersSource: false, sessionsSource: false },
    requires: { dbTables: ['sessions'], shopifyToken: false },
  },
  {
    id: 'breakdown_best_geo_products',
    page: 'Countries',
    name: 'Best by GEO table',
    ui: { elementIds: ['best-geo-products-table'] },
    endpoint: { method: 'GET', path: '/api/stats', params: ['range=...'] },
    sources: [
      { kind: 'db', tables: ['sessions'], note: 'Country + product landing sessions (started_at in range, human-only; handle parsed from first_path/first_product_handle/entry_url)' },
      { kind: 'db', tables: ['orders_shopify', 'orders_shopify_line_items'], note: 'Truth orders by order country (shipping/billing from orders_shopify.raw_json) + product revenue from line items' },
      { kind: 'shopify', note: 'Product meta (handle + thumb) via cached Products API' },
      { kind: 'fx', note: 'Revenue converted to GBP' },
    ],
    columns: [
      { name: 'Country', value: 'sessions.country_code' },
      { name: 'CR', value: 'converted / total', formula: 'Product orders / (country + product landing sessions)' },
      { name: 'Orders', value: 'converted', formula: 'COUNT(DISTINCT order_id) containing the product (truth line items)' },
      { name: 'Sessions', value: 'total', formula: 'COUNT(sessions) started_at in range for that country AND that product handle (human-only)' },
      { name: 'Rev', value: 'revenue (GBP)', formula: 'SUM(line_revenue) converted to GBP' },
    ],
    math: [
      { name: 'Important', value: 'Denominator is now exact country+product sessions (not country-wide website sessions).' },
    ],
    respectsReporting: { ordersSource: false, sessionsSource: false },
    requires: { dbTables: ['sessions', 'orders_shopify', 'orders_shopify_line_items'], shopifyToken: true },
  },
  {
    id: 'insights_abandoned_carts_series_chart',
    page: 'Abandoned Carts',
    name: 'Abandoned carts series chart',
    ui: { elementIds: ['abandoned-carts-chart'] },
    endpoint: {
      method: 'GET',
      path: '/api/abandoned-carts/series',
      params: [
        'range=today|yesterday|3d|7d|14d|30d|month|d:YYYY-MM-DD|r:YYYY-MM-DD:YYYY-MM-DD',
        'timezone/timeZone',
        'mode=cart|checkout',
      ],
    },
    sources: [
      { kind: 'db', tables: ['sessions'], note: 'Counts sessions by abandoned_at buckets with mode filter (cart_qty>0 vs checkout_started_at not null)' },
      { kind: 'fx', note: 'cart_value converted to GBP (fx.getRatesToGbp + convertToGbp)' },
      { kind: 'pixel', note: 'cart_qty/cart_value/checkout_started_at populated via /api/ingest; abandonment markers are set by cleanup marker pass' },
    ],
    columns: [
      { name: 'Chart title', value: 'totalAbandonedGbp', formula: 'SUM(cart_value) for abandoned sessions in range, converted to GBP' },
      { name: 'Line series', value: 'series[].abandoned', formula: 'COUNT(sessions) that became abandoned in each bucket (abandoned_at in bucket)' },
    ],
    math: [
      { name: 'Bucket', value: 'Hour buckets for ~single-day ranges; day buckets for multi-day ranges.' },
      { name: 'Time basis', value: 'abandoned_at is set to last_seen + ABANDONED_WINDOW_MINUTES when marked abandoned.' },
      { name: 'Mode', value: 'cart: cart_qty>0; checkout: checkout_started_at IS NOT NULL (both exclude has_purchased=1).' },
    ],
    respectsReporting: { ordersSource: false, sessionsSource: false },
    requires: { dbTables: ['sessions'], shopifyToken: false },
  },
  {
    id: 'insights_abandoned_carts_top_countries_table',
    page: 'Abandoned Carts',
    name: 'Top countries (abandoned)',
    ui: { elementIds: ['abandoned-carts-countries-table'] },
    endpoint: {
      method: 'GET',
      path: '/api/abandoned-carts/top-countries',
      params: [
        'range=...',
        'timezone/timeZone',
        'mode=cart|checkout',
        'limit=5 (optional)',
      ],
    },
    sources: [
      { kind: 'db', tables: ['sessions'], note: 'Abandoned sessions grouped by session country (COALESCE(country_code, cf_country)) and summed cart_value' },
      { kind: 'fx', note: 'cart_value converted to GBP' },
      { kind: 'pixel', note: 'Session geo + cart fields from ingest; is_abandoned/abandoned_at from cleanup marker pass' },
    ],
    columns: [
      { name: 'Country', value: 'rows[].country', formula: 'UPPER(SUBSTR(COALESCE(country_code, cf_country, XX),1,2))' },
      { name: 'Abandoned', value: 'rows[].abandoned', formula: 'COUNT(abandoned sessions in range for mode)' },
      { name: 'Checkout', value: 'rows[].checkout_sessions', formula: 'COUNT(sessions with checkout_started_at in range for that country)' },
      { name: '% Abandoned', value: 'rows[].abandoned_pct', formula: 'cart mode: abandoned / cart_sessions(started_at in range, cart_qty>0); checkout mode: abandoned / checkout_sessions' },
      { name: 'Value', value: 'rows[].abandoned_value_gbp', formula: 'SUM(cart_value) for abandoned sessions, converted to GBP' },
    ],
    math: [
      { name: 'Sort', value: 'Ordered by abandoned count (desc).' },
      { name: 'Country basis', value: 'Session country comes from session geo (can differ from Shopify order address country).' },
    ],
    respectsReporting: { ordersSource: false, sessionsSource: false },
    requires: { dbTables: ['sessions'], shopifyToken: false },
  },
  {
    id: 'insights_abandoned_carts_top_country_products_table',
    page: 'Abandoned Carts',
    name: 'Top country + product (abandoned, landing attribution)',
    ui: { elementIds: ['abandoned-carts-country-products-table'] },
    endpoint: {
      method: 'GET',
      path: '/api/abandoned-carts/top-country-products',
      params: [
        'range=...',
        'timezone/timeZone',
        'mode=cart|checkout',
        'limit=5 (optional)',
      ],
    },
    sources: [
      { kind: 'db', tables: ['sessions'], note: 'Grouped by session country + landing product (sessions.first_product_handle)' },
      { kind: 'shopify', note: 'Best-effort: resolve product_title for top handles (requires token if available)' },
      { kind: 'fx', note: 'cart_value converted to GBP' },
    ],
    columns: [
      { name: 'Country + Product', value: 'rows[].country + rows[].product_title', formula: 'Landing attribution: LOWER(TRIM(first_product_handle))' },
      { name: 'Abandoned', value: 'rows[].abandoned' },
      { name: 'Checkout', value: 'rows[].checkout_sessions', formula: 'COUNT(sessions with same country+handle that reached checkout in range)' },
      { name: '% Abandoned', value: 'rows[].abandoned_pct', formula: 'cart mode: abandoned / cart_sessions(started_at in range, cart_qty>0); checkout mode: abandoned / checkout_sessions' },
      { name: 'Value', value: 'rows[].abandoned_value_gbp' },
    ],
    math: [
      { name: 'Important', value: 'This table is product-specific within each country (not country-wide sessions).' },
    ],
    respectsReporting: { ordersSource: false, sessionsSource: false },
    requires: { dbTables: ['sessions'], shopifyToken: false },
  },
  {
    id: 'insights_abandoned_carts_sessions_table',
    page: 'Abandoned Carts',
    name: 'Abandoned sessions table (paginated)',
    ui: { elementIds: ['sessions-table', 'tab-panel-abandoned-carts'] },
    endpoint: {
      method: 'GET',
      path: '/api/abandoned-carts/sessions',
      params: [
        'range=...',
        'timezone/timeZone',
        'mode=cart|checkout',
        'limit, offset',
      ],
    },
    sources: [
      { kind: 'db', tables: ['sessions', 'visitors'], note: 'Sessions list + returning flags + device/network columns' },
      { kind: 'db', tables: ['events'], note: 'Used for session history + side panel (via /api/session-details)' },
      { kind: 'shopify', note: 'Best-effort landing title enrichment (handle → title) for session landing column' },
    ],
    columns: [
      { name: 'Landing Page', value: 'sessions.first_path / sessions.first_product_handle (enriched title best-effort)' },
      { name: 'GEO', value: 'COALESCE(s.country_code, v.last_country, s.cf_country)' },
      { name: 'Source', value: 'sessions.traffic_source_key' },
      { name: 'Device', value: 'visitors.device + sessions.ua_device_type/ua_platform' },
      { name: 'Cart', value: 'sessions.cart_qty + sessions.cart_value' },
      { name: 'Arrived', value: 'sessions.started_at' },
      { name: 'Seen', value: 'sessions.last_seen' },
    ],
    math: [
      { name: 'Filter', value: 'is_abandoned=1 AND has_purchased=0 AND abandoned_at in range, plus mode filter (cart_qty>0 vs checkout_started_at not null).' },
      { name: 'Sort', value: 'ORDER BY abandoned_at desc, last_seen desc.' },
    ],
    respectsReporting: { ordersSource: false, sessionsSource: false },
    requires: { dbTables: ['sessions', 'visitors', 'events'], shopifyToken: false },
  },
  {
    id: 'products_best_sellers',
    page: 'Products',
    name: 'Best sellers table',
    ui: { elementIds: ['best-sellers-table'] },
    endpoint: { method: 'GET', path: '/api/shopify-best-sellers', params: ['shop=...', 'range=...', 'page/pageSize'] },
    sources: [
      { kind: 'db', tables: ['sessions'], note: 'Product landing sessions (first_path/entry_url → handle, fallback first_product_handle; human-only)' },
      { kind: 'db', tables: ['orders_shopify_line_items'], note: 'Shopify truth product orders/revenue from line items (paid only)' },
      { kind: 'shopify', note: 'Product meta (handle + thumb) via cached Products API' },
    ],
    columns: [
      { name: 'Orders', value: 'orders', formula: 'COUNT(DISTINCT order_id) containing the product (truth line items)' },
      { name: 'Sessions', value: 'clicks', formula: 'COUNT(sessions) that landed on this product (human-only)' },
      { name: 'Rev', value: 'revenue', formula: 'SUM(line_revenue) for the product (truth)' },
      { name: 'CR%', value: 'cr', formula: 'orders / sessions × 100' },
    ],
    math: [
      { name: 'Note', value: 'Orders/Rev are Shopify truth (product line items). Sessions are product landings from our sessions table.' },
      { name: 'Sort', value: 'Ordered by revenue (desc) then orders.' },
    ],
    respectsReporting: { ordersSource: false, sessionsSource: false },
    requires: { dbTables: ['sessions', 'orders_shopify_line_items'], shopifyToken: true },
  },
  {
    id: 'products_best_variants',
    page: 'Products',
    name: 'Best variants table',
    ui: { elementIds: ['best-variants-table'] },
    endpoint: { method: 'GET', path: '/api/shopify-best-variants', params: ['shop=...', 'range=...', 'page/pageSize'] },
    sources: [
      { kind: 'db', tables: ['sessions'], note: 'Product landing sessions for the parent product handle (first_path/entry_url → handle, fallback first_product_handle; human-only)' },
      { kind: 'db', tables: ['orders_shopify_line_items'], note: 'Shopify truth variant orders/revenue from line items (paid only)' },
      { kind: 'shopify', note: 'Product meta (handle + thumb) via cached Products API' },
    ],
    columns: [
      { name: 'Orders', value: 'orders', formula: 'COUNT(DISTINCT order_id) containing this variant (truth line items)' },
      { name: 'Sessions', value: 'clicks', formula: 'COUNT(product landing sessions for the parent product)' },
      { name: 'Rev', value: 'revenue', formula: 'SUM(line_revenue) for this variant (truth)' },
      { name: 'CR%', value: 'cr', formula: 'orders / sessions × 100' },
    ],
    math: [
      { name: 'Note', value: 'Sessions is per parent product (variants of the same product share the same Sessions denominator).' },
      { name: 'Sort', value: 'Ordered by revenue (desc) then orders.' },
    ],
    respectsReporting: { ordersSource: false, sessionsSource: false },
    requires: { dbTables: ['sessions', 'orders_shopify_line_items'], shopifyToken: true },
  },
  {
    id: 'insights_variants_tables',
    page: 'Variants',
    name: 'Variants insight tables (custom mappings)',
    ui: { elementIds: ['variants-tables-row', 'variants-all-stats-btn', 'variants-all-stats-modal'] },
    endpoint: { method: 'GET', path: '/api/insights-variants', params: ['shop=...', 'range=...'] },
    sources: [
      { kind: 'db', tables: ['orders_shopify_line_items'], note: 'Truth orders/revenue by variant_id + variant_title (paid line items, converted to GBP)' },
      { kind: 'db', tables: ['sessions'], note: 'Variant-specific sessions from entry_url ?variant=<id> (human-only)' },
      { kind: 'db', tables: ['settings'], note: 'Mappings from settings.insights_variants_config_v1 (table + rule aliases)' },
      { kind: 'fx', note: 'Revenue converted to GBP (fx.getRatesToGbp)' },
    ],
    columns: [
      { name: 'Variant', value: 'rule label from mapping config' },
      { name: 'Sessions', value: 'COUNT(sessions) where landing variant_id maps to this rule' },
      { name: 'Orders', value: 'COUNT(DISTINCT order_id) for mapped variant_ids (truth line items)' },
      { name: 'CR%', value: 'orders / sessions × 100' },
      { name: 'Rev', value: 'SUM(line_revenue) for mapped variant_ids (GBP)' },
    ],
    math: [
      { name: 'Mapping model', value: 'Rule matching is alias include; overlap is auto-resolved by most-specific include token (ties use rule order).' },
      { name: 'Validation', value: 'Settings save is allowed even with unmapped in-scope titles; the server returns coverage warnings to guide mapping/ignore. Table scope is inferred (e.g. length/style tables skip out-of-scope titles). Overlap-resolved counts are diagnostic context, not a blocking category.' },
      { name: 'Attribution caveat', value: 'Sessions depend on landing URLs with ?variant=<id>; default-option landings without variant param can under-attribute variant sessions.' },
      { name: 'Seeding', value: 'Settings → Insights → Variants includes “Suggest mappings” which seeds editable custom tables from Shopify selectedOptions + recent observed variant activity (API: GET /api/insights-variants-suggestions (optional refresh=1), POST /api/insights-variants-suggestions/apply).' },
      { name: 'Table aliases', value: 'Each mapping table can include aliases (e.g. Size, Chain Length, Bracelet Length). Aliases help scope inference and allow suggestion seeding to merge multiple Shopify option labels into one table.' },
      { name: 'Table icons', value: 'Each mapping table can set an optional FontAwesome class string (e.g. fa-solid fa-grid-round) used on the Variants card header.' },
    ],
    respectsReporting: { ordersSource: false, sessionsSource: false },
    requires: { dbTables: ['settings', 'sessions', 'orders_shopify_line_items'], shopifyToken: false },
  },
  {
    id: 'traffic_channels',
    page: 'Traffic',
    name: 'Channels table',
    ui: { elementIds: ['traffic-sources-table'] },
    endpoint: { method: 'GET', path: '/api/traffic', params: ['range=...'] },
    sources: [
      { kind: 'db', tables: ['sessions'], note: 'Sessions grouped by sessions.traffic_source_key (human-only)' },
      { kind: 'db', tables: ['orders_shopify', 'settings', 'traffic_source_meta', 'traffic_source_rules'], note: 'Orders/revenue from Shopify truth orders. Source is derived from orders_shopify.raw_json (landing_site/referring_site) + mapping rules. Enabled channels come from settings.traffic_sources_enabled; labels/icons can be overridden via traffic_source_meta.' },
      { kind: 'fx', note: 'Revenue converted to GBP' },
    ],
    columns: [
      { name: 'Sessions', value: 'COUNT(sessions) started_at in range (human-only)' },
      { name: 'Orders', value: 'orders', formula: 'COUNT(truth orders) in range for that derived source' },
      { name: 'Rev', value: 'revenueGbp', formula: 'Truth revenue in GBP' },
      { name: 'CR%', value: 'orders / sessions × 100' },
    ],
    math: [
      { name: 'Note', value: 'Orders/Rev are Shopify truth. Sessions come from our sessions table; CR% = Orders / Sessions.' },
      { name: 'Settings', value: 'Visible channels are controlled by settings.traffic_sources_enabled (Settings → Traffic).' },
    ],
    respectsReporting: { ordersSource: false, sessionsSource: false },
    requires: { dbTables: ['sessions'], shopifyToken: false },
  },
  {
    id: 'traffic_types',
    page: 'Traffic',
    name: 'Traffic type table (device → platform)',
    ui: { elementIds: ['traffic-types-table'] },
    endpoint: { method: 'GET', path: '/api/traffic', params: ['range=...'] },
    sources: [
      { kind: 'db', tables: ['sessions', 'settings'], note: 'Sessions grouped by ua_device_type + ua_platform (human-only). Enabled device keys come from settings.traffic_types_enabled.' },
      { kind: 'db', tables: ['orders_shopify'], note: 'Orders/revenue from Shopify truth orders, with device/platform derived from orders_shopify.raw_json client_details.user_agent' },
      { kind: 'fx', note: 'Revenue converted to GBP' },
    ],
    columns: [
      { name: 'Sessions', value: 'COUNT(sessions) started_at in range (human-only)' },
      { name: 'Orders', value: 'orders', formula: 'COUNT(truth orders) in range for that device/platform bucket' },
      { name: 'Rev', value: 'revenueGbp', formula: 'Truth revenue in GBP' },
      { name: 'CR%', value: 'orders / sessions × 100' },
    ],
    math: [
      { name: 'Settings', value: 'Visible device types are controlled by settings.traffic_types_enabled (Settings → Traffic).' },
    ],
    respectsReporting: { ordersSource: false, sessionsSource: false },
    requires: { dbTables: ['sessions'], shopifyToken: false },
  },
  {
    id: 'tools_shipping_cr',
    page: 'Tools',
    name: 'Shipping CR tool',
    ui: { elementIds: ['tool-shipping-cr'] },
    endpoint: {
      method: 'POST',
      path: '/api/tools/shipping-cr/labels',
      params: [
        'country_code=ISO2 (e.g. AU)',
        'start_ymd=YYYY-MM-DD',
        'end_ymd=YYYY-MM-DD',
        'shop=... (optional)',
      ],
    },
    sources: [
      { kind: 'db', tables: ['orders_shopify_shipping_options'], note: 'Per-order shipping option facts (derived from Shopify truth orders; no request-time JSON parsing)' },
      { kind: 'db', tables: ['orders_shopify', 'reconcile_state'], note: 'Truth cache populated by salesTruth reconciliation; shipping options upsert runs during reconcile' },
      { kind: 'db', tables: ['sessions'], note: 'Checkout-started session counts by country (human-only)' },
    ],
    columns: [
      { name: 'Country', value: 'orders_shopify_shipping_options.order_country_code (shipping/billing country from Shopify order payload)' },
      { name: 'Shipping label', value: 'orders_shopify_shipping_options.shipping_label (from Shopify shipping_lines[].title)' },
      { name: 'Paid shipping', value: 'orders_shopify_shipping_options.shipping_price_paid (presentment amount; falls back to shipping_price)', formula: 'What was actually charged for shipping' },
      { name: 'Set shipping', value: 'orders_shopify_shipping_options.shipping_price_set (presentment amount; falls back to paid)', formula: 'Listed/set shipping rate presented at checkout' },
      { name: 'Sessions', value: 'COUNT(sessions) WHERE (checkout_started_at OR purchased_at) in range AND country matches via country_code→cf_country fallback (human-only; constant across rows)', formula: 'Checkout-or-purchase sessions for the selected country+range' },
      { name: 'CR%', value: 'orders / total_orders × 100', formula: 'Share of orders for that shipping label+price within the selected country+timeframe' },
    ],
    math: [
      { name: 'Important', value: 'CR% here is a share-of-orders metric (per shipping option), not Orders/Sessions. Sessions is shown only as context (checkout-or-purchase sessions for the selected country+range).' },
      { name: 'Date basis', value: 'Filters by orders_shopify.processed_at when present; falls back to created_at when processed_at is NULL. Bounds use admin timezone (getRangeBounds r:YYYY-MM-DD:YYYY-MM-DD).' },
    ],
    respectsReporting: { ordersSource: false, sessionsSource: false },
    requires: { dbTables: ['orders_shopify_shipping_options', 'sessions'], shopifyToken: false },
  },
  {
    id: 'tools_click_order_lookup',
    page: 'Tools',
    name: 'Click & Order Lookup tool',
    ui: { elementIds: ['tool-click-order-lookup', 'lookup-results'] },
    endpoint: {
      method: 'GET',
      path: '/api/tools/click-order-lookup',
      params: ['q=session_id|order_id|checkout_token|purchase_key', 'shop=... (optional)'],
    },
    sources: [
      { kind: 'db', tables: ['sessions', 'visitors'], note: 'Session + visitor context for click ID' },
      { kind: 'db', tables: ['purchases', 'purchase_events'], note: 'Evidence keys and purchase linkage (order_id / checkout_token / purchase_key)' },
      { kind: 'db', tables: ['orders_shopify'], note: 'Shopify truth order lookup (when shop is known)' },
      { kind: 'db', tables: ['affiliate_attribution_sessions'], note: 'Captured attribution signals for the session (UTMs + click IDs)' },
      { kind: 'db', tables: ['fraud_evaluations', 'fraud_config'], note: 'Fraud bundle (session/purchase/order evaluations + threshold) + resolution metadata' },
      { kind: 'ai', note: 'Optional: AI narrative generation for triggered evals (feature-flagged; async; cached)' },
    ],
    columns: [
      { name: 'Resolved IDs', value: 'Click ID (session_id), Visitor ID, Checkout token, Shopify order ID, Kexo order key' },
      { name: 'Session', value: 'Geo/device/source/UTMs/entry/referrer + timestamps' },
      { name: 'Purchases', value: 'Purchases for the resolved session (most recent first)' },
      { name: 'Fraud', value: 'Fraud evaluations + deterministic/AI narrative + safe evidence snapshot' },
      { name: 'Attribution', value: 'affiliate_attribution_sessions row + JSON fields (paid_click_ids / affiliate_click_ids / last_seen)' },
      { name: 'Truth order', value: 'orders_shopify row when shop is provided/resolved' },
      { name: 'Purchase events', value: 'purchase_events rows for order_id/checkout_token when shop is provided' },
    ],
    math: [
      { name: 'Resolution strategy', value: 'Lookup prefers indexed fraud_evaluations links first; falls back to limited purchases lookups to avoid heavy scans (order_id/checkout_token are not indexed in purchases).' },
    ],
    respectsReporting: { ordersSource: false, sessionsSource: false },
    requires: { dbTables: ['sessions', 'purchases'], shopifyToken: false },
  },
  {
    id: 'settings_charts_panel',
    page: 'Settings',
    name: 'Charts settings panel',
    ui: { elementIds: ['settings-charts-root', 'settings-charts-save-btn', 'settings-charts-reset-btn'] },
    endpoint: { method: 'GET/POST', path: '/api/settings', params: ['chartsUiConfig (POST body)'] },
    sources: [
      { kind: 'db', tables: ['settings'], note: 'charts_ui_config_v1 persisted in settings table' },
      { kind: 'ui', note: 'Client applies chart mode/colors/enabled via app.js + localStorage cache key kexo:charts-ui-config:v1' },
    ],
    columns: [],
    math: [
      { name: 'Scope', value: 'Global/shared (not per-user)' },
      { name: 'Apply behavior', value: 'Saved config is used for chart mode/colors/visibility; disabled charts are hidden server-side via /theme-vars.css' },
    ],
    respectsReporting: { ordersSource: false, sessionsSource: false },
    requires: { dbTables: ['settings'], shopifyToken: false },
  },
  {
    id: 'settings_layout_tables_panel',
    page: 'Settings',
    name: 'Layout settings panel (tables)',
    ui: { elementIds: ['settings-layout-tables-root', 'settings-layout-tables-save-btn', 'settings-layout-tables-reset-btn'] },
    endpoint: { method: 'GET/POST', path: '/api/settings', params: ['tablesUiConfig (POST body)'] },
    sources: [
      { kind: 'db', tables: ['settings'], note: 'tables_ui_config_v1 persisted in settings table' },
      { kind: 'ui', note: 'Client applies table rows/options + sticky sizing + order/grid via app.js + localStorage cache key kexo:tables-ui-config:v1' },
    ],
    columns: [],
    math: [
      { name: 'Scope', value: 'Global/shared (not per-user)' },
      { name: 'Apply behavior', value: 'Config overrides table rows-per-page options/default and (optionally) sticky column min/max. Table title/order/grid are applied via DOM transforms (opt-in titles via data-kexo-table-title).' },
    ],
    respectsReporting: { ordersSource: false, sessionsSource: false },
    requires: { dbTables: ['settings'], shopifyToken: false },
  },
  {
    id: 'settings_diagnostics_panel',
    page: 'Settings',
    name: 'Diagnostics panel (sales/traffic/pixel/google-ads/system/definitions)',
    ui: { elementIds: ['diagnostics-content', 'config-refresh-btn', 'config-reconcile-btn'] },
    endpoint: { method: 'GET', path: '/api/config-status', params: ['shop=... (optional)'] },
    sources: [
      { kind: 'db', tables: ['settings', 'shop_sessions', 'sessions', 'purchase_events', 'purchases', 'orders_shopify'], note: 'Health + drift + reporting config' },
      { kind: 'shopify', note: 'ShopifyQL sessions + Web Pixel settings (when token stored)' },
    ],
    columns: [],
    math: [
      { name: 'Refresh action', value: 'Refresh button re-fetches diagnostics payload only (no writes).' },
      { name: 'Reconcile action', value: 'Reconcile button POSTs /api/reconcile-sales?range=7d to force truth sync, then refreshes diagnostics.' },
      { name: 'Shopify Sessions (today)', value: 'ShopifyQL: FROM sessions SHOW sessions DURING today' },
      { name: 'Kexo Sessions (today)', value: 'sessions started today (human sessions if cf_known_bot tagging exists)' },
      { name: 'Evidence sessions (today)', value: "purchase_events: COUNT(DISTINCT session_id) where event_type IN ('checkout_completed','checkout_started') (debug only; can be < truth)" },
      { name: 'Shopify CR% (today)', value: 'ShopifyQL conversion_rate (sessions table; matches Shopify Admin)' },
      { name: 'Kexo CR% (today)', value: 'Truth Orders / Human Sessions × 100 (Kexo-only comparison)' },
      { name: 'Truth Orders/Revenue', value: 'orders_shopify paid orders (all channels)' },
      { name: 'Checkout-token Orders/Revenue', value: 'orders_shopify paid orders where checkout_token is set (online-store proxy)' },
      { name: 'Pixel Orders/Revenue', value: 'purchases table (deduped) from checkout_completed evidence' },
      { name: 'Evidence (checkout_completed)', value: 'purchase_events rows (append-only) + link coverage to truth' },
    ],
    respectsReporting: { ordersSource: false, sessionsSource: false },
    requires: { dbTables: ['settings'], shopifyToken: false },
  },
];

module.exports = {
  DEFINITIONS_VERSION,
  LAST_UPDATED,
  TRACKER_TABLE_DEFINITIONS,
};

